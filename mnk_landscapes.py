# multiobjective NK landscapes

import torch
import matplotlib.pyplot as plt
import itertools

import fitness.fitness_functions as ff

import numpy as np


class Rmnk():
    """
    Implementation of the multiobjective NK landscapes with tunable objective correlation.
    The problem is compatible with files generated
    by the mocobench generator http://mocobench.sourceforge.net/index.php?n=Problem.RMNK

    Example:

    >>> from moead_framework.problem.combinatorial import Rmnk
    >>>
    >>> # The file is available here : https://github.com/moead-framework/data/blob/master/problem/RMNK/Instances/rmnk_0_2_100_1_0.dat
    >>> # Others instances are available here : https://github.com/moead-framework/data/tree/master/problem/RMNK/Instances
    >>> instance_file = "moead_framework/test/data/instances/rmnk_0_2_100_1_0.dat"
    >>> rmnk = Rmnk(instance_file=instance_file)
    >>>
    >>> # Generate a new solution
    >>> solution = rmnk.generate_random_solution()
    >>>
    >>> # Print all decision variables of the solution
    >>> print(solution.decision_vector)
    >>>
    >>> # Print all objectives values of the solution
    >>> print(solution.F)
    """

    dtype = float

    def __init__(self, instance_file=None, rho=None, m=None, n=None, k=None, links=None, tables=None):
        f"""
        Constructor of the problem. 
        You can initialize the problem directly by using an instance file or by setting parameters : rho, m, n, k, links and tables. 
        http://mocobench.sourceforge.net/index.php?n=Problem.RMNK#Format

        :param instance_file: {str} text file generated by the rmnk generator : http://mocobench.sourceforge.net/index.php?n=Problem.RMNK#Code
        :param rho: {float} the objective correlation coefficient
        :param m: {int} the number of objective functions
        :param n: {int} the length of solutions
        :param k: {list} the number of epistatic links (non-linearity)
        :param links: {list} describe the epistatic structure between variables
        :param tables: {list} describe the fitness contribution
        """
        self.rho = None
        self.m = None
        self.n = None
        self.k = None
        self.links = None
        self.tables = None
        self.instance_file = None

        if instance_file is not None:
            if not isinstance(instance_file, str):
                raise TypeError("The expected type of `instance_file` is `str`")
            self.init_with_instance_file(instance_file=instance_file)
        elif (rho is not None) & (m is not None) & (n is not None) & (k is not None) & (links is not None) & (
                tables is not None):
            self.init_with_data(rho=rho, m=m, n=n, k=k, links=links, tables=tables)
        else:
            msg = "The constructor needs either the instance_file parameter or the following parameters : " \
                  "rho, m, n, k, links and tables."
            raise ValueError(msg)

        # super().__init__(objective_number=self.m)


    def init_with_instance_file(self, instance_file):

        if isinstance(instance_file, str):
            self.instance_file = instance_file
        else:
            raise TypeError("The instance_file parameter must be a string.")

        file = open(instance_file, 'r')
        file_content = list(map(str.strip, file.readlines()))
        file_content = file_content[3:]

        definition = file_content[0].split(" ")
        self.rho = float(definition[2])
        self.m = int(definition[3])
        self.n = int(definition[4])
        self.k = int(definition[5])

        # super().__init__(objective_number=self.m)

        self.links = np.zeros((self.m, self.n, self.k + 1))

        self.tables = np.zeros((self.m, self.n, 1 << (self.k + 1)))

        file_content = file_content[2:]
        line = self.load_links(file_content)

        file_content = file_content[line + 1:]
        self.load_tables(file_content)

        file.close()

    def init_with_data(self, rho, m, n, k, links, tables):

        if isinstance(m, int) & isinstance(n, int) & isinstance(k, int):
            self.m = m
            self.n = n
            self.k = k
        else:
            raise TypeError("The parameters m, n and k must be positive integers.")

        if isinstance(rho, (int, float)):
            self.rho = rho
        else:
            raise TypeError("The parameter rho must be a float.")

        if isinstance(links, list) & isinstance(tables, list):
            self.links = links
            self.tables = tables
        else:
            raise TypeError("The parameters links and tables must be list.")

    def f(self, function_id: int, decision_vector: np.ndarray):
        """
        Evaluate the decision_vector for the objective function_id

        :param function_id: {integer} index of the objective
        :param decision_vector: {:class:`~moead_framework.solution.one_dimension_solution.OneDimensionSolution`} solution to evaluate
        :return: {float} fitness value
        """
        if not isinstance(function_id, int):
            raise TypeError("The expected type of `function_id` is `int`")

        if not isinstance(decision_vector, np.ndarray):
            raise TypeError("The expected type of `decision_vector` is `np.ndarray`")

        accu = 0

        for i in range(self.n):
            accu += self.tables[function_id][i][self.sigma(function_id, decision_vector, i)]

        return -1 * (accu / self.n)


    def sigma(self, function_id, solution_array, item):
        """
        Compute the sigma value

        :param function_id: {integer} index of the objective function
        :param solution_array: {list<integer>} representation of the solution
        :param item: {integer} index of the variable
        :return:
        """
        n = 1
        accu = 0

        for j in range(self.k + 1):
            link = int(self.links[function_id][item][j])
            if solution_array[link]:
                accu = accu | n

            n = n << 1

        return accu


    def generate_random_solution(self):
        """
        Generate a random solution for the current problem

        :return: {:class:`~moead_framework.solution.one_dimension_solution.OneDimensionSolution`}
        """

        return self.evaluate(x=np.random.randint(0, 2, self.n).tolist()[:])


    def load_links(self, file_content):
        """
        Load links from the instance file

        :param file_content: {list<float>} content of the instance file
        :return: {integer} the number of line
        """
        line = 0
        for i in range(self.n):
            for j in range(self.k + 1):
                s = file_content[line].split("  ")
                line += 1
                for n in range(self.m):
                    self.links[n][i][j] = float(s[n])

        return line


    def load_tables(self, file_content):
        """
        Load tables from the instance file

        :param file_content: {list<float>} content of the instance file
        :return:
        """
        line = 0
        for i in range(self.n):
            for j in range(1 << (self.k + 1)):
                s = file_content[line].split("  ")
                line += 1
                for n in range(self.m):
                    self.tables[n][i][j] = float(s[n])
                    
import numpy as np
import torch
from move_config import MoveConfig

class MNKConfig(MoveConfig):
    def __init__(self, *args, **kwargs):
        self.rmnk_instance_file = 'data/rmnk_0_2_100_1_0.dat'
        return super().__init__(*args, **kwargs)

class MNKGenome():
    current_id = 1 # 0 reserved for 'random' parent
    
    @staticmethod
    def get_id():
        __class__.current_id += 1
        return __class__.current_id - 1
    
    def __init__(self, config:MNKConfig, do_init=True):
        self.genome = torch.zeros(config.rmnk_n)
        self.id = -1
        self.parents = (-1, -1)
        self.age = 0
        self.lineage = []
        self.cell_lineage = []
        self.n_cells = 0
        self.device = config.device # TODO:unused
        self.id = -1
        if do_init:
            self.id = type(self).get_id()
            self.genome = torch.rand(config.rmnk_n)
            
        self.sgd_lr = 0.0             # TODO: shouldn't need this
        self.enabled_connections = [] # TODO: shouldn't need this
        self.hidden_nodes = []        # TODO: shouldn't need this
        self.input_nodes = []         # TODO: shouldn't need this
        self.output_nodes = []        # TODO: shouldn't need this
        self.nodes = []               # TODO: shouldn't need this
        self.genome = self.genome > 0.5
        self.genome = self.genome.to(torch.float32)
        
    def mutate(self, config):
        mask = torch.rand(config.rmnk_n) < config.mutation_percent
        # flip bits
        self.genome = self.genome.to(torch.int32) ^ mask
        self.genome = self.genome.to(torch.float32)
        
        # 
        # self.genome += torch.randn(config.rmnk_n) * config.mutation_sigma * mask
        # self.genome = torch.clamp(self.genome, 0, 1)
        # self.genome = self.genome > 0.5
        # self.genome = self.genome.to(torch.float32)

        
    def clone(self, config, cpu=False, new_id=False):
        child = MNKGenome(config, do_init=False)
        child.genome = self.genome.clone()
        if new_id:
            child.id = type(self).get_id()
            child.parents = (self.id, self.id)
            child.lineage = self.lineage + [self.id]
        else:
            child.id = self.id 
            child.parents = self.parents
            child.lineage = self.lineage
        return child
    
    def to(self, device):
        self.genome = self.genome.to(device)
        return self
    
    def to_json(self):
        return {}
    
    def save(self, path, config):
        torch.save(self.genome, path)
    
    def prune(self, config):
        pass # No pruning
        return 0,0 # Did not prune anything

    def forward(self, x, channel_first=True, force_recalculate=True, use_graph=False, act_mode='n/a'):
        return self.genome
    
    def __call__(self, *args, **kwargs):
        return self.forward(*args, **kwargs)



def evaluate_genomes(genomes, rmnk, objective_i, config):
    fitness_values = [rmnk.f(objective_i, g.genome.numpy()) for g in genomes]
    return torch.tensor(fitness_values, dtype=torch.float32, device=config.device)

if __name__ == "__main__":
    import os
    from move import MOVE
    from run_setup import run_setup

    for config, verbose in run_setup(config_class=MNKConfig):
        
        # Initialize RMNK problem
        # rho = Objective correlation coefficient
        # m = Number of objective functions
        # n = Length of solutions
        # k = Number of epistatic links (non-linearity)


        print("Loading RMNK instance from", config.rmnk_instance_file)
        rmnk = Rmnk(instance_file=config.rmnk_instance_file)
        config.rmnk_r = rmnk.rho
        config.rmnk_m = rmnk.m
        config.rmnk_n = rmnk.n
        config.rmnk_k = rmnk.k
        
        print("RMNK:", config.rmnk_r, config.rmnk_m, config.rmnk_n, config.rmnk_k)


        config.mutation_sigma = 0.4
        config.mutation_percent = 0.05


        fitness_functions = []

        for i in range(config.rmnk_m):
            fn = lambda genomes, i=i, config=config, rmnk=rmnk: -1.0 * evaluate_genomes(genomes, rmnk, i, config) # invert sign to maximize
            fn.__name__ = f"Objective {i}"
            fitness_functions.append(fn)
            ff.register_fitness_function(fn.__name__, fn, True)
            ff.NO_NORM.append(fn)
            ff.NO_MEAN.append(fn)
            
        
        
        if not hasattr(config, 'output_dir'):
            config.output_dir = "../results/nsga-mnk"
        config.mutate_sgd_lr_sigma = False
        config.move_fns_per_cell = 3
        config.num_cells =  len(list(itertools.combinations(torch.arange(config.rmnk_m),  config.move_fns_per_cell))) # use all the cells possible
        config.num_cells = min(256, config.num_cells)
        config.initial_batch_size = config.num_cells
        config.batch_size = config.num_cells
        config.enforce_initial_fill = True
        # config.num_cells =  
        config.objective_functions = fitness_functions
        config.sgd_steps = 0
        config.genome_type = MNKGenome
        config.target=None
        alg = MOVE(config, debug_output=verbose)
        alg.evolve()
        